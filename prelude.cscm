(define first car)
(define (second x) (car (cdr x)))
(define (third x) (car (cdr (cdr x))))
(define (map f xs)
  (if (null? xs)
      '()
      (cons (f (car xs)) (map f (cdr xs)))))
(defmacro (and . xs)
  (cond
    [(null? xs) #t]
    [(null? (cdr xs)) (car xs)]
    [else (list 'if (car xs)
                (cons 'and (cdr xs))
                #f)]))
(defmacro (quasiquote x)
  (define (skip n x) 0) ; Fix me
  (cond
    [(pair? x)
     (let ([f (first x)])
       (cond
         [(eq? f 'unquote) (second x)]
         [(and (pair? f) (eq? (first f) 'unquote-splicing))
          (list 'append (second f) (cons 'quasiquote (cdr x)))]
         [(eq? f 'quasiquote) (list 'list ''quasiquote (skip 1 (second x)))]
         [else (list 'cons (list 'quasiquote f) (list 'quasiquote (cdr x)))]))]
    [else (list 'quote x)]))
